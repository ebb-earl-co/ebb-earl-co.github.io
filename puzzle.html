<h1><a href="https://youtu.be/1giVzxyoclE?t=134">What’s In the Box</a>!?</h1>
<p>For Christmas, I was gifted a lovely alternative to wasteful wrapping paper that just ends up in the landfill: the <a href="https://www.amazon.com/Secret-Puzzles-Treasure-Compartment-Mystery/dp/B097RBFYC6">BSIRI Jigsaw Safe Box</a>. As can be seen in the image below, it features two plain sides, and two sides with five sliders each:</p>
<p><img src="https://m.media-amazon.com/images/I/71tm37PRoKL._AC_SL1500_.jpg" alt="BSIRI Jigsaw Safe Box" width="480" height="480"></p>
<h2>The Problem Space</h2>
<p>In order to open the box and get to the goody(ies) inside, each of the sliders needs to be in the proper position, exactly like the tumblers in a standard key-opened lock. There are three positions for each shelf:</p>
<ol>
<li>Slid to the left; &quot;Left&quot;</li>
<li>Unmoved in the center; &quot;Center&quot;</li>
<li>Slid to the right; &quot;Right&quot;</li>
</ol>
<p>In the image above, the first four sliders are in position &quot;Right&quot; and the bottom shelf is in position &quot;Center&quot;: this is one of the possible solutions to unlock this side of the puzzle box (spoiler: it is not the solution for this side.)</p>
<h3>Antisymmetry</h3>
<p>The two sides of the puzzle box are <strong>not</strong> unlocked by the same combination. This is not obvious, and it not advertised by the product description, but after having solved it, it turns out to be the case. Moreover, the two sides with sliders are identifiable as only one of the sides with sliders has an indented circle above the sliders: visible in the image above.</p>
<h2>The Math(s)</h2>
<p>The set of positions for a given slider is <img src="https://i.upmath.me/svg/S%3D%5C%7B%5Ctext%7BLeft%2C%20Center%2C%20Right%7D%5C%7D" alt="S=\{\text{Left, Center, Right}\}" />. The <strong>size</strong> of <img src="https://i.upmath.me/svg/S" alt="S" />, a.k.a. the cardinality of <img src="https://i.upmath.me/svg/S" alt="S" />, is three, as there are three elements in <img src="https://i.upmath.me/svg/S" alt="S" />: the notation is <img src="https://i.upmath.me/svg/%7CS%7C%20%3D%203" alt="|S| = 3" />.
Given that:</p>
<ul>
<li>The sliders have the same set of positions, <img src="https://i.upmath.me/svg/S" alt="S" />,</li>
<li>The sliders’ positions are independent of one another,</li>
<li>and that the sides’ sliders are independent of each other,</li>
</ul>
<p>there are the following number of solution configurations possible <em>for the side with an inlaid circle</em>:
<img src="https://i.upmath.me/svg/%7C%5C%7B%5Ctext%7BTop%20slider%20positions%7D%5C%7D%7C%5Ccdot%20%7C%5C%7B%5Ctext%7BSecond%20slider%20positions%7D%5C%7D%7C%20%5Ccdot%20%7C%5C%7B%5Ctext%7BThird%20slider%20positions%7D%5C%7D%7C%20%5Ccdot%20%7C%5C%7B%5Ctext%7BFourth%20slider%20positions%7D%5C%7D%7C%20%5Ccdot%20%7C%5C%7B%5Ctext%7BFifth%20slider%20positions%7D%5C%7D%7C%20%3D" alt="|\{\text{Top slider positions}\}|\cdot |\{\text{Second slider positions}\}| \cdot |\{\text{Third slider positions}\}| \cdot |\{\text{Fourth slider positions}\}| \cdot |\{\text{Fifth slider positions}\}| =" /></p>
<p align="center"><img align="center" src="https://i.upmath.me/svg/%7CS%7C%20%5Ccdot%20%7CS%7C%20%5Ccdot%20%7CS%7C%20%5Ccdot%20%7CS%7C%20%5Ccdot%20%7CS%7C%20%3D%20" alt="|S| \cdot |S| \cdot |S| \cdot |S| \cdot |S| = " /></p>
<p align="center"><img align="center" src="https://i.upmath.me/svg/3%5Ccdot%203%5Ccdot%203%5Ccdot%203%5Ccdot%203%20%3D" alt="3\cdot 3\cdot 3\cdot 3\cdot 3 =" /></p>
<p align="center"><img align="center" src="https://i.upmath.me/svg/3%5E5%20%26%3D%20243" alt="3^5 &amp;= 243" /></p>
<p>The same is true for the opposite side of the puzzle box, the slider side <strong>without</strong> the punched-in circle. However, this does <strong>not</strong> simply double the amount of possible configurations, as the two sides are independent; rather, the number of possible configurations is analagous to multiplying the number of configurations of the sliders by each other since those are independent: the two sides’ number of slider configurations are multiplied by each other, giving us
<img src="https://i.upmath.me/svg/%5Ctext%7BTotal%20number%20of%20configurations%7D%20%3D%203%5E5%20%5Ccdot%203%5E5%20%3D%20(3%5E5)%5E2%20%3D%203%5E%7B10%7D%20%3D%2059%2C049" alt="\text{Total number of configurations} = 3^5 \cdot 3^5 = (3^5)^2 = 3^{10} = 59,049" />
However, we know that, for our puzzle box, the two sides do not have the same unlocking configuration, so there is a non-zero amount of matching configurations in the two groups of 243 configurations. How many are there? Exactly as many as the amount of configurations for a given side, $3^5 = 243$! Therefore, <strong>for this puzzle box</strong>, the total number of configurations possible to unlock it is</p>
<p align="center"><img align="center" src="https://i.upmath.me/svg/%5Ctext%7BPuzzle%20box%20slider%20configurations%7D%20%3D%203%5E%7B10%7D%20-%203%5E%7B5%7D%20%3D%203%5E5%5Ccdot(3%5E5%20-1)%20%3A%3D%20C%20%3D%2058%2C806" alt="\text{Puzzle box slider configurations} = 3^{10} - 3^{5} = 3^5\cdot(3^5 -1) := C = 58,806" /></p>
<p>*N.b. the <img src="https://i.upmath.me/svg/%3A%3D" alt=":=" /> symbol means that a variable (in this case <img src="https://i.upmath.me/svg/C" alt="C" />) is being <strong>defined</strong> by the previous expression, or <strong>initialized</strong> to have a value.</p>
<h2>The Probability</h2>
<p>The probability of naïvely hitting the exact configuration to unlock the box on the first try is <img src="https://i.upmath.me/svg/%5Cfrac%7B1%7D%7B3%5E%7B10%7D%20-%203%5E5%7D%20%3D%20%5Cfrac%7B1%7D%7B58%2C806%7D%20%3D%200.00001701" alt="\frac{1}{3^{10} - 3^5} = \frac{1}{58,806} = 0.00001701" />, which is about 17 in a million. This is what makes for such a good puzzle! Unless you don’t like brute force algorithms, in which case all I can say is that the world’s bicycle locks thank you for your lack of persistence!</p>
<h2>The Code</h2>
<p>Writing anything fifty-eight thousand eight hundred six times would be a chore, nevermind listing subtle repetitions of the same three words. So, let’s enlist the help of a computer. The following Python code will set up the objects discussed so far, and verify the counts and numbers claimed. There is no automation for solving the puzzle box in meat space, but running the provided code as one tries different combinations is an excellent companion to the solving process.</p>
<pre><code class="language-python">&gt;&gt;&gt; top_slider_configurations, second_slider_configurations, third_slider_configurations, fourth_slider_configurations, fifth_slider_configurations = [(&quot;Left&quot;, &quot;Center&quot;, &quot;Right&quot;)] * 5
&gt;&gt;&gt; top_slider_configurations
('Left', 'Center', 'Right')
&gt;&gt;&gt; number_of_puzzle_box_side_configurations: int = 0
&gt;&gt;&gt; for _ in top_slider_configurations:
        for _ in second_slider_configurations:
            for _ in third_slider_configurations:
                for _ in fourth_slider_configurations:
                    for _ in fourth_slider_configurations:
                        number_of_puzzle_box_side_configurations += 1
else:
    print(number_of_puzzle_box_side_configurations)
...
243
</code></pre>
<p>To not be overly verbose, we will use the <code>product()</code> function from the Python standard library module <code>itertools</code>: it creates the giant array (that we will call <code>puzzle_box_side_configurations</code>) that is belied by the code above: every collection of a configuration from each of the slider configurations. From <em>that</em> collection, we make an <code>itertools.product</code> object out of two copies of <code>puzzle_box_side_configurations</code>. Lastly, we filter out of that collection the configurations that are the same, and we are left with an object that has a two-tuple of puzzle box side configurations for each of the 58,806 possible configurations.</p>
<pre><code class="language-python">&gt;&gt;&gt; import itertools
&gt;&gt;&gt; puzzle_box_side_configurations = list(itertools.product(top_slider_configurations, second_slider_configurations, third_slider_configurations, fourth_slider_configurations, fifth_slider_configurations))
&gt;&gt;&gt; len(puzzle_box_side_configurations)
243
&gt;&gt;&gt; total_configurations = itertools.product(puzzle_box_side_configurations, puzzle_box_side_configurations)
&gt;&gt;&gt; puzzle_box_configurations = list(config for config in total_configurations if config[0] != config[1])
&gt;&gt;&gt; C: int = len(puzzle_box_configurations)
&gt;&gt;&gt; C
58806
</code></pre>
<h2>The Strategy</h2>
<p>To best keep track of what one has and has not tried, use the <code>puzzle_box_configurations</code> object in a Python REPL: as <code>puzzle_box_configurations</code> is a Python <code>list</code> object, it has a <code>.pop()</code> method which discards its last element. So, the algorithm becomes:</p>
<ol>
<li>execute <code>puzzle_box_configurations.pop()</code></li>
<li>Read that configuration, set the physical puzzle box to that configuration, and try to open the box by gently pulling</li>
<li>If the puzzle box opens, great! That’s problem solved. If not, then go back to step <code>1.</code></li>
</ol>
<p>E.g.</p>
<pre><code class="language-python">&gt;&gt;&gt; puzzle_box_configurations.pop()
(('Right', 'Right', 'Right', 'Right', 'Right'), ('Right', 'Right', 'Right', 'Right', 'Center'))
</code></pre>
<p>meaning that the slider side with the inlaid circle would set all sliders to the right setting; and the reverse side would set all but the bottom slider to the right setting, and its bottom slider to the center setting.</p>
<h3>Alternative strategy</h3>
<p>It is disheartening to think about whittling down a list of almost sixty thousand options, especially as checking each option requires physical manhandling of the puzzle box. Also, practically, it is difficult to hold 10 different sliding pieces of wood in the correct position while pulling on the top of the box.</p>
<p>So, we can split the problem into finding the correct configuration for each side of the puzzle in series. When I attemped the puzzle, I started with the side without the inlaid circle, but it is immaterial which is solved first and which second. In this situation, the strategy is the same, except that only 243 options are gone through: psychologically, this is somehow much more palatable. In code:</p>
<pre><code class="language-python">&gt;&gt;&gt; circle_side_configurations, plain_side_configurations = (puzzle_box_side_configurations, puzzle_box_side_configurations)
&gt;&gt;&gt; circle_side_configurations.pop()
('Right', 'Right', 'Right', 'Right', 'Right')
&gt;&gt;&gt; # This is not the correct configuration
&gt;&gt;&gt; circle_side_configurations.pop()
('Right', 'Right', 'Right', 'Right', 'Center')
...
</code></pre>
<h1>Conclusion</h1>
<p>This is a very lovely gift: it is constructed well and has a decent amount of space inside of it to store something valuable. I ended up needing somewhere around 100 attempts to solve first the side without the inlaid circle, and then several hundred attempts to solve the other side. So, all said, I lucked out in the problem space! This problem space also gave me a bit better intuition about the enormity of <img src="https://i.upmath.me/svg/2%5E%7B256%7D" alt="2^{256}" />, highlighted in a recent <a href="https://www.youtube.com/watch?v=X4jpqCu-wlA">video from 3Blue1Brown</a>. The problem space of this puzzle box is unimaginably smaller than that of 256-bit encryption, so we should rest assured that various computer operations should be secure for some time to come.</p>
<p>In the meantime, happy puzzling.</p>
